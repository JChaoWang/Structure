# 知识体系

## HTML面试知识点

### 标准模式和兼容模式的区别

> 标准模式的渲染方式和JS引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以狂送的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。

### HTML5各种元素的定义

> HTML5中，元素被分成两大类:inline（内联元素）与block（块级元素）。一个行内元素只占据它对应的标签的边框所包含的空间。

> 行内元素：a b span img strong sub sup button input label select

> 块级元素：div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p

> 空元素：br hr img input link meta

> link标签定义文档和外部资源的关系。link元素是空元素，它仅包含属性。此元素只能存在于head部分，不过它可出现任何次数。link标签中的rel属性定义了当前文档和被链接文档之间的关系。常见的stylesheet指的是定义一个外部加载的样式表。

> 行内元素与块级元素的区别：

> 1、格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。

> 2、内容上，默认情况下，行内元素只能包含文本和其他行内元素，而块级元素可以包含行内元素和其他块级元素。

> 3、行内元素和元素属性的不同，主要是盒模型属性上：行内元素设置width无效，height无效（可以设置line-height），设置margin和padding的上下不会对其他元素产生影响。

### 页面导入样式时，使用link和@import的区别

> 1、从属关系区别。@import是css提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载css文件，还可以定义RSS、rel连接属性、引入网站图标等。

> 2、加载顺序区别。加载页面时，link标签引入的css被同时加载；@import引入的css将在页面加载完毕后被加载。

> 3、兼容性区别。@import是CSS2.1才有的语法，故只可在IE5+才能识别；link标签作为HTML元素，不存在兼容性问题。

> 4、DOM可控性区别。可以通过JS操作DOM，插入link标签来改变样式；由于DOM方法是基于文档的，无法使用@import的方式插入样式。

### 浏览器的渲染原理

> 1、首先解析收到的文档，根据文档定义构建一棵DOM树，DOM树是由DOM元素以及属性节点组成的。

> 2、然后对CSS进行解析，生成CSSOM规则树。

> 3、根据DOM树和CSSOM规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和DOM元素相对应，但这种对应关系不是一对一的，不可见的DOM元素不会插入渲染树。还有一些DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。

> 4、当渲染对象被创建并添加到树中，他们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情就要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。

> 5、布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的paint方法将它们的内容显示在屏幕上，绘制使用UI基础组件。值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能的早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

### 渲染过程中遇到JS文件怎么处理，以及async和defer的作用和区别

> JavaScript的加载、解析与执行会阻塞文档的解析，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停文档的解析，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中的地方恢复继续解析文档。

> 也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载JS文件，这也就是都建议将script标签放在body标签底部的原因。当然在当下，并不是说script标签必须放在底部，因为你可以给script标签添加defer或者async属性。

> async和defer的作用和区别:

> 1、脚本没有defer或async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。

> 2、defer属性表示延迟执行引入的JavaScript，即这段JavaScript加载时HTML并未停止解析，这两个过程是并行的。当整个document解析完毕后再执行脚本文件，再DOMContentLoaded事件触发之前发成。多个脚本按顺序执行。

> 3、async属性表示异步执行引入的JavaScript，与defer的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。

### 什么是重绘和回流，如何减少回流

> 重绘：当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如background-color。

> 回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作。

> 常见引起回流属性和方法：

> 1、添加或者删除可见的DOM元素；

> 2、元素尺寸该改变--边距、填充、边框、宽度和高度；

> 3、内容变化，比如用户在input框中输入文字；

> 4、浏览器窗口尺寸改变--resize事件发生时；

> 5、计算offsetWidth和offsetHeight属性；

> 6、设置style属性的值；

> 7、当你修改网页的默认字体时；

> 如何减少回流：

> 1、使用transform替代top；

> 2、不要把节点的属性值放在一个循环里当成变量；

> 3、不要是用table布局，可能很小的一个小改动会造成整个table的重新布局；

> 4、把DOM离线后修改；

> 5、不要一条一条地修改DOM的样式；

### HTML5新增哪些特性、移除了哪些

> 新增的有：

> 绘画canvas；

> 用于媒介回放的video和audio元素；

> 本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失；sessionStorage的数据在浏览器关闭后自动删除；

> 语义化更好的内容元素，比如article、footer、header、nav、section

> 表单控件，calendar、date、time、Email、url、search

> 新的技术webworker，websocket

> 新的文档属性 document.visibilityState

> 移除的元素有：

> 纯表现的元素：basefont，big，center，font，s，strike，tt，u；

> 对可用性产生负面影响的元素：frame，frameset，noframes；

### iframe的缺点

> 1、iframe会阻塞主页面的onload事件。window的onload事件需要在所有iframe加载完毕后（包含里面的元素）才会触发。在Safari和Chrome里，通过JavaScript动态设置iframe的src可以避免这种阻塞情况。

> 2、搜索引擎的检索程序无法解读这种页面，不利于网页的SEO。

> 3、iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

> 4、浏览器的后退按钮失效。

> 5、小型的移动设备无法完全显示框架。

### 如何实现浏览器内多个标签页之间的通信

> 1、使用WebSocket，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。

> 2、使用 SharedWorker （只在 chrome 浏览器实现了），两个页面共享同一个线程，通过向线程发送数据和接收数据来实现标签页之间的双向通行。

> 3、如果我们能够获得对应标签页的引用，通过 postMessage 方法也是可以实现多个标
签页通信的。

### 常用的 meta 标签

> meta元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。

> meta标签位于文档的头部，不包含任何内容。meta标签的属性定义了与文档相关联的名称/值对。

```
<!DOCTYPE html> H5 标准声明，使用 HTML5 doctype，不区分大小写
<head lang=”en”> 标准的 lang 属性写法
<meta charset=’utf-8′> 声明文档使用的字符编码
<meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/> 优先使用 IE 最新版
本和 Chrome
<meta name=”description” content=”不超过 150 个字符”/> 页面描述
<meta name=”keywords” content=””/> 页面关键词者
<meta name=”author” content=”name, email@gmail.com”/> 网页作
<meta name=”robots” content=”index,follow”/> 搜索引擎抓取
<meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”> 为移动设备添加 viewport
<meta name=”apple-mobile-web-app-title” content=”标题”> iOS 设备 begin
<meta name=”apple-mobile-web-app-capable” content=”yes”/> 添加到主屏后的标题（iOS 6
新增）
是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏
<meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”>
添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）
<meta name=”apple-mobile-web-app-status-bar-style” content=”black”/>
<meta name=”format-detection” content=”telphone=no, email=no”/> 设置苹果工具栏颜色
<meta name=”renderer” content=”webkit”> 启用 360 浏览器的极速模式(webkit)
<meta http-equiv=”X-UA-Compatible” content=”IE=edge”> 避免 IE 使用兼容模式
<meta http-equiv=”Cache-Control” content=”no-siteapp” /> 不让百度转码
<meta name=”HandheldFriendly” content=”true”> 针对手持设备优化，主要是针对一些
老的不识别 viewport 的浏览器，比如黑莓
<meta name=”MobileOptimized” content=”320″> 微软的老式浏览器
<meta name=”screen-orientation” content=”portrait”> uc 强制竖屏
<meta name=”x5-orientation” content=”portrait”> QQ 强制竖屏
<meta name=”full-screen” content=”yes”> UC 强制全屏
<meta name=”x5-fullscreen” content=”true”> QQ 强制全屏
<meta name=”browsermode” content=”application”> UC 应用模式
<meta name=”x5-page-mode” content=”app”> QQ 应用模式
<meta name=”msapplication-tap-highlight” content=”no”> windows phone 点击无高光
设置页面不缓存<meta http-equiv=”pragma” content=”no-cache”>
<meta http-equiv=”cache-control” content=”no-cache”>
<meta http-equiv=”expires” content=”0″>
```

### 前端性能优化

#### 1、页面内容方面

> 1、通过文件合并、css雪碧图、使用base64等方式来减少HTTP请求数，避免过多的请求造成的等待的情况

> 2、通过DNS缓存等机制来减少DNS的查询次数

> 3、通过设置缓存策略，对常用不败你的资源进行缓存

> 4、使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要要访问时，再去请求加载

> 5、通过用户行为，对某些资源使用预加载的方式，来提高用需要访问资源时的响应速度

#### 2、服务器方面

> 1、把样式表放在页面的head标签中，减少页面的首次渲染时间

> 2、避免使用@import标签

> 3、尽量把js脚本放在页面底部或者使用defer或async属性，避免脚本的加载和执行阻塞页面的渲染

> 4、通过对JavaScript和CSS的文件进行压缩，来减少文件的体积

## CSS面试知识点

### CSS选择符有哪些

> id选择器

> 类选择器

> 标签选择器

> 后代选择器

> 相邻后代选择器

> 兄弟选择器

> 相邻兄弟选择器

> 属性选择器

> 伪类选择器

> 伪元素选择器

> 通配符选择器

### position有哪些值

> absolute 生成绝对定位的元素，相对于值不为static的第一个父元素的paddingbox进行定位，也可以理解为离自己这一级元素最近的以及position设置为absolute或者relative的父元素的paddingbox的左上角为原点的。

> fixed（老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。

> relative生成相对定位的元素，相对于其元素本身所在正常位置进行定位。

> static默认值。没有定位，元素出现在正常的流中。

> inherit 规定从父元素继承position属性的值。

### 对BFC规范（块级格式化上下文）的理解

> BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品排放，并且不会影响其他环境中的物品。

> 创建BFC

> 1、根元素或包含根元素的元素

> 2、浮动元素float

> 3、绝对定位元素position=absolute或fixed

> 4、display＝inline-block|flex|inline-flex|table-cell 或 table-caption

> 5、overflow＝hidden|auto 或 scroll(≠visible)

### 使用 rem 布局的优缺点

> 优点：在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放；

> 缺点：

> 1、在奇葩的dpr设备上表现效果不太好

> 2、使用iframe引起也会出现问题

> 3、rem在多屏尺寸适配上与当前两大平台的设计哲学不一致

## JavaScript面试知识点

### JavaScript 有几种类型的值？你能画一下他们的内存图

> 栈：原始数据类型（Undefined、Null、Boolean、Number、String）

> 堆：引用数据类型（对象、数组和函数）

### null和undefined的区别

> Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，
就是 undefined 和 null。undefined 代表的含义是未定义，null 代表的含义是空对象

### JavaScript 的基本规范

> 一个函数作用域中所有的变量声明应该尽量提到函数首部

> 代码中出现地址、时间等字符串时需要使用常量代替

> 在进行比较的时候吧，尽量使用'===', '!=='代替'==', '!='。

> switch 语句必须带有 default 分支。

> 不要在内置对象的原型上添加方法，如 Array, Date。

> for循环必须使用大括号

> if语句必须使用大括号

### JavaScript 原型，原型链？ 有什么特点

> 在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们是不应该能够获取到这个值的，但是现在浏览器中都实现__proto__ 属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对象的原型。当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是我们新建的对象为什么能够使用 toString()等方法的原因。

### JavaScript创建对象的几种方式

> 1、工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。

> 2、构造函数模式，js 中每一个函数都可以作为构造函数，只要一个函数是通过 new
来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。

> 3、原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数
对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。

### JavaScript继承的几种实现方式

> 1、原型链继承

> 2、构造函数继承

> 3、组合继承

> 4、原型式继承

> 5、寄生式继承

> 6、寄生式组合继承

### Javascript 的作用域链

> 作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。

### This 对象的理解

> this时执行上下文的一个属性，它指向最后依次调用这个方法的对象。在实际开发中，this的指向可以通过四种调用模式来判断。

> 1、函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this指向全局对象。

> 2、方法调用模式，如果一个函数作为一个对象的方法来调用时，this指向这个对象。

> 3、构造器调用模式，如果一个函数用new调用时，函数执行前会创建一个对象，this指向这个新创建的对象。

> 4、apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指
向除了使用 new 时会被改变，其他情况下都不会改变。

### 什么是闭包，为什么要用它

> 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。闭包有两个常用的用途。闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。

### 如何创建一个Ajax

> 1、创建一个XMLHttpRequest对象，也就是创建一个异步调用对象

> 2、创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息

> 3、设置响应HTTP请求状态变化的函数

> 4、发送HTTP请求

> 5、获取异步调用返回的数据

> 6、使用JavaScript和DOM实现局部刷新

### 浏览器的缓存机制

> 浏览器的缓存机制指的是通过一段时间内保留已接收的web资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用web缓存可以有效地提高页面的打开的速度，减少不必要的网络带宽的消耗。web资源缓存策略一般由服务器来指定，可以分为两种，强缓存和协商缓存。

> 强缓存：如果缓存资源有效，则直接使用缓存资源，不必要向服务器发起请求。强缓存是通过设置http请求头信息中的Expires属性和Cache-Control属性。服务器欧通过在响应头中添加Expires属性，来指定资源的过期时间，这是一个绝对时间。这是http1.0中的方式。在http1.1中，是通过Cache-Control属性，同时是通过设置max-age来指定缓存的时间的大小，这是个相对时间来进行控制。Cache-Control优先级高于Expires。

> 协商缓存：会先向服务器发送一个请求，如果资源没有发生修改，则返回一个304状态，让浏览器使用本地的缓存副本。协商缓存时通过设置http请求头中的Etag和Last-Modified属性。服务器通过在响应头中添加Last-Modified属性来指出资源最后一次修改的时间，当浏览器下次发起请求时，会在请求头中添加If-Modified-Since的属性，属性值为上一次资源返回的Last-Modified的值。由于精确度 之呢个精确到秒级，所以缓存不准确。另外一个方式时通过Etag属性，时服务器在返回资源的时候，在头部信息中添加Etag属性，这个属性时资源生成的唯一标识，资源修改时会同步修改。Etag优先级高于Last-Modified。

### 如何解决凯越问题

> 1、jsonp跨越（利用script标签src没有同源限制）

> 2、跨越资源共享（CORS）

> 3、nginx代理跨域

> 4、postMessage跨域

> 5、document.domain + iframe跨越

### call（）和apply（）的区别

> apply接受两个参数，第一个参数指定了函数体内this对象的指向，第二个为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数。call传入的参数数量不固定，跟apply相同的时，第一个参数也是代表函数体内的this指向，从第二个参数开始往后，每个参数一次传入函数。

### 如何编写高性能的JavaScript

> 1、使用位运算代替简单的四则运算

> 2、避免使用过深的嵌套循环

> 3、不要使用未定的变量

> 4、当需要多次访问数组长度时，可以利用变量保存起来，避免每次都会进行属性查找

### V8引擎的垃圾回收机制

> V8的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另外一个是不死的对象会活得更久。V8引擎内存分为了新生代和老生代。新创建的对象或者只经历一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。

> 新生代被分为From和To两个空间，To一般是闲置的。当From空间满了的时候会执行Scavenge算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束再继续执行。这个算法分为三步：

> 1、首先检查From空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足则晋升到老生代。如果不是则移动到To空间。

> 2、对象不存活，则释放对象空间。

> 3、最后将From空间和To空间角色进行交换。

### 哪些操作会造成内存泄漏

> 1、意外的全局变量

> 2、被遗忘的计数器或回调函数

> 3、脱离DOM的引用

> 4、闭包

### js 的节流与防抖

```
// 函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。
// 函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。
// 函数防抖的实现
function debounce(fn, wait) {
  var timer = null;
  return function() {
    var context = this,
    args = arguments;
    // 如果此时存在定时器的话，则取消之前的定时器重新记时
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    // 设置定时器，使事件间隔指定事件后执行
    timer = setTimeout(() => {
      fn.apply(context, args);
    }, wait);
  };
}

// 函数节流的实现;
function throttle(fn, delay) {
  var preTime = Date.now();
  return function() {
    var context = this,
    args = arguments,
    nowTime = Date.now();
    // 如果两次时间间隔超过了指定时间，则执行函数。
    if (nowTime - preTime >= delay) {
      preTime = Date.now();
      return fn.apply(context, args);
    }
  };
}

```

### JavaScript的事件循环机制

> 因为JavaScript是单线程运行的。在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js引擎并不会一直等待其返回结果，而是将这个事件挂起，继续执行执行栈中的其他的任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈不同的另一个任务队列中等待执行。任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队的事件压入栈中执行。当微任务队列中的任务都执行完成后再去判断宏任务队列中的任务。

> 微任务包括了promise的回调、node中的process.nextTick、对DOM变化的监听的MutationObserver。

> 宏任务包括了script脚本的执行、setTimeOut、setInterval、setImmediate一类的定时事件，还有I/O操作、UI值

### JavaScript深浅拷贝实现

> 浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用Object.assign和展开运算符来实现。

> 深拷贝相对浅拷贝而言，不是只是将引用的地址复制给对象，而是新建一个指针指向引用类型的地址。JSON的两个方法或者递归方法。

### 函数柯里化的实现

> 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技
术。

### 什么是 XSS 攻击？如何防范 XSS 攻击

> xss攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过网站注入恶意脚本，使之在用户浏览器上运行，从而盗取用户信息和cookie。防范手段对cookie设置http-only的设置。

### 什么是 CSRF 攻击？如何防范 CSRF 攻击

> CSRF攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。利用其登录状态向服务器发送请求。

> 1、同源检测的方法。（http请求头中origin或者referer信息）

> 2、使用CSRF Token进行验证

> 3、使用使用双重Cookie验证的办法

> 4、设置cookie属性的时候设置Samesite

### 什么是点击劫持？如何防范点击劫持？

> 点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。（通过设置http响应头的X-FRAME-OPTIONS）

### 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？

> MVC、MVP和MVVM是三种常见的软件架构设计模式，主要是通过分离关注点的方式来组织代码结构，优化我们的开发效率。

> MVC通过分离Model、View和Controller的方式来组织代码结构；其中View负责页面的显示逻辑，Model负责存储页面的业务数据，以及对应数据的操作。并且View和Model应用了观察者模式，当Model层发生改变的时候它会通知有关View层更新页面。Controller层是View层和Model层的纽带，它主要是负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller中的事件触发器就开始工作了，通过调用Model层，来完成对Model层的修改，然后Model层再去通知View层更新。

> MVP模式与MVC唯一不同的在于Presenter和Controller。在MVC模式中我们使用观察者模式，来实现当Model层数据发生变化的时候，通知View层的更新。这样View层和Model层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP的模式通过使用Presenter来实现对View层和Model层的解耦。MVC中的Controller只知道Model的接口，因此他们有办法控制View层的更新，MVP模式中，View层的接口暴露给了Presenter因此我们可以在Presenter中将Model的变化和View的变化绑定在一起，以此来实现View和Model的同步更新。这样实现了对View和Model的解耦，Presenter还包含了其他的响应逻辑。

> MVVM模式中的VM，指的是ViewModel，它和MVP的思想其实是相同的，不过它通过双向的数据绑定，将View和Model的同步更新给自动化了。当Model发生变化的时候，ViewModel就会自动更新；ViewModel变化了，View也会更新。这样就将Presenter中的工作给自动化了。（双向数据绑定原理---vue----使用数据劫持和发布订阅者模式）

### vue 双向数据绑定原理

> vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。

> 首先我们通过 Object.defineProperty() 方法来对 Model 数据各个属性添加访问器属性，以此来实现数据的劫持，因此当 Model 中的数据发生变化的时候，我们可以通过配置的setter 和 getter 方法来实现对 View 层数据更新的通知。

> Object.defineProperty 函数一共有三个参数，第一个参数是需要定义属性的对象，第二个参数是需要定义的属性，第三个是该属性描述符。

> 一个属性的描述符有四个属性，分别是 value 属性的值，writable 属性是否可写，
enumerable 属性是否可枚举，configurable 属性是否可配置修改。

> 缺点：有一些对属性的操作，使用这种方法无法拦截，比如说通过下标方式修改数组数据或者给对象新增属性，vue 内部通过重写函数解决了这个问题。在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用 Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为这是 ES6 的语法。

### 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？

> 使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 js 对象树给保存下来，最后再将 DOM片段插入到文档中。当页面的状态发生改变，我们需要对页面的DOM的接口进行调整的时候，我们首先根据变更的状态，重新构建一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录两者的差异。

> diff算法：两个数的完全diff算法的时间复杂度为O（n^3），但是在前端中，很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样可以将算法的时间复杂度降低为O（n）。

> 算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号，在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。

> 在对列表元素进行对比的时候，由于TagName是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个key，列表对比的时候使用key来进行比较，这样我们才能复用老的DOM树上的节点。

### 谈谈你对 webpack 的看法

> webpack主要的原理是，它将所有的资源都看成一个模块，并且把页面逻辑当作一个整体，通过一个给定的入口文件，webpack从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过loader和plugins处理后，然后打包在一起，最后输出一个浏览器可识别的JS文件。

> Webpack 具有四个核心的概念，分别是 Entry（入口）、Output（输出）、loader 和 Plugins（插件）。

> Entry 是 webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。

> Output 属性告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。

> loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件。在对 loader 进行配置的时候，test 属性，标志有哪些后缀的文件应该被处理，是一个正则表达式。use 属性，指定 test 类型的文件应该使用哪个 loader 进行预处理。常用的 loader 有css-loader、style-loader 等。

> 插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，要使用一个插件，一般是先使用 npm 包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给plugins 数组属性。

> 使用 webpack 的确能够提供我们对于项目的管理，但是它的缺点就是调试和配置起来太麻烦了。但现在 webpack4.0 的免配置一定程度上解决了这个问题。但是我感觉就是对我来说，就是一个黑盒，很多时候出现了问题，没有办法很好的定位。

### 谈一谈你理解的函数式编程

> 简单说，"函数式编程"是一种"编程范式"（programming paradigm），也就是如何编写程序的方法论。它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是"第一等公民"、只用"表达式"。

### 异步编程的实现方式

> 1、回调函数的方式，代码耦合性高，不利于维护；

> 2、Promise的方式，多个嵌套的回调函数作为链式调用，可能造成代码的语义不够明确；

> 3、使用 generator 的方式；

> 4、使用 async 函数的形式；

### Set和WeakSet结构、Map和WeakMap结构

> Set和WeakSet结构：ES6提供了新的数据结构Set。类似于数组，但是成员的值都是唯一的，没有重复的值。但是WeakSet中的成员只能是对象，而不能是其他类型的值。

> Map和WeakMap结构：ES6提供了新的数据结构Map。类似于对象，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。但是WeakMap只接受对象作为键名（null除外）不计入垃圾回收机制，而不能是其他类型的值。

### 什么是 Proxy

> Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。

### computed和watch的差异

> 1、computed是计算一个新的属性，并将该属性挂载到Vue实例上，而watch是监听已经存在且已挂载到Vue实例上的数据，所以watch同样可以监听computed计算属性的变化。

> 2、computed本质是一个惰性求值的观察者，是具有缓存性，只有当依赖变化后，第一次访问computed属性，才会计算新的值。而watch数据发生变化便会调用执行函数。

> 3、从使用场景上说，computed适用一个数据被多个数据影响，而watch适用一个数据影响多个数据。

### vue-router相关

> 1、全局的钩子函数beforeEach和afterEach

> 2、单个路由独享的钩子函数beforeEnter它是在路由配置上直接进行定义的

> 3、组件内的导航钩子函数有三种：beforeRouteEnter、beforeRouteUpdate、
beforeRouteLeave

> 4、如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。

> 实现原理：

> 1、Hash----利用URL中的hash（“#”）

> > hash（“#”）的作用是加载 URL 中指示网页中的位置

> > 可以为 hash 的改变添加监听事件

> > 每一次改变 hash(window.localtion.hash)，都会在浏览器访问历史中增加一个记录。利用 hash 的以上特点，就可以来实现前端路由"更新视图但不重新请求页面"的功能了

> > HashHistory 拥有两个方法，一个是 push， 一个是 replace

> 2、History----利用 History interface 在HTML5中新增的方法

> > History interface 是浏览器历史记录栈提供的接口，通过back()、forward()、go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。

> > 从 HTML5开始，History interface 提供了2个新的方法：pushState()、replaceState() 使得我们可以对浏览器历史记录栈进行修改

> 两者的区别：

> 1、pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL

> 2、pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串

> 3、pushState可额外设置title属性供后续使用

> 4、history模式则会将URL修改得就和正常请求后端的URL一样,如后端没有配置对应/user/id的路由处理，则会返回404错误

### mixin和mixins

> mixin 用于全局混入，会影响到每个组件实例。

> mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并

## react知识点

### React的特点

> 1、Declarative(声明式编码)

> 2、Component-Based(组件化编码)

> 3、高效

### React高效的原因

> 1、虚拟(virtual)DOM, 不总是直接操作真实DOM(批量更新, 减少更新的次数)

> 2、高效的DOM Diff算法, 最小化DOM更新

### React的jsx

> 1、JSX 是一个看起来很像 XML 的 js 语法扩展

> 2、作用: 创建虚拟DOM(元素对象)

> 3、浏览器不能直接运行, 需要使用babel转换成纯JS语法: React.createElement()

> 4、相比于纯JS要编码更简洁易读

> 5、注意: JSX标签必须有结束, 组件标签首字母必须大写

### 区别类组件和函数式组件

> 1、类组件: 使用class定义的组件, 会产生组件对象, 可以有自身的状态和生命周期勾子

> 2、函数组件: 使用function定义的组件, 不产生组件对象, 没有自身的状态和生命周期勾子

> 3、补充: 有了hooks语法后, 函数组件也可以有状态了

> 4、state: 值为容器对象, 保存的是组件内可变的数据,组件根据state中的数据显示, 要更新界面只要更新state即可

> 5、props: 值为容器对象, 保存的是从组件外传递过来的数据, 当前组件只读, 父组件修改了自动显示新数据

> 6、refs: 值为容器对象, 保存的是n个有ref属性的dom元素对象, 属性名是ref指定的标识名称, 值为对应的dom元素

### 为什么虚拟dom和dom diff算法能提高性能

> 1、虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。

> 2、具体实现步骤如下：

> - 用一般JS对象表示DOM树的结构, 然后用这个树构建一个真正的 DOM 树显示到页面

> - 当状态更新的时候，重新构造一棵新的对象树

> - 然后用新树和旧树进行diff比较, 得到虚拟DOM的差异, 并转化成对应的DOM更新

> 3、Dom Diff算法：

> - 把树形结构按照层级分解，只比较同级元素。给列表结构的每个单元添加唯一的key属性，方便比较。

> - React 只会匹配相同类名的 component合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.

> - 在每一个事件循环结束时, React 检查所有标记 dirty 的 component 重新绘制.选择性子树渲染。

> - 开发人员可以重写shouldComponentUpdate提高diff的性能。

### 调用 setState 之后发生了什么

> 1、React 会将传入的参数对象与组件当前的状态合并产生了新的state

> 2、生成新的虚拟DOM树 ==> render()

> 3、计算出新树与老树的节点差异，然后做真实DOM的差异更新

### 比较react中组件间3种通信方式

> 1、通过props传递

> > 1、通过props可以传递一般属性和函数属性

> > 2、一般属性–>父组件向子组件

> > 3、函数属性–>子组件向父组件通信

> > 4、缺点: 只能一层一层传递/兄弟组件必须借助父组件

> 2、消息订阅(subscribe)-发布(publish)机制

> > 1、实现库: pubsub-js

> > 2、组件A: 发布消息(相当于触发事件)

> > 3、组件B: 订阅消息, 接收消息, 处理消息(相当于绑定事件监听)

> > 4、优点: 对组件关系没有限制

> 3、redux

> > 1、通过redux可以实现任意组件间的通信

> > 2、集中式管理多个组件共享的状态, 而pubsub-js并不是集中式的管理

### 何为高阶组件(higher order component)

> 1、高阶组件是一个以组件为参数并返回一个新组件的函数

> 2、HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是Redux 的 connect 函数

> 3、如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC

> 4、作用：

> > 1、代码重用，逻辑和引导抽象

> > 2、渲染劫持

> > 3、状态抽象和控制

> > 4、props 控制

### Redux遵循的三个原则是什么

> 1、单一事实来源：整个应用的状态存储在单个 store 中的对象/状态树里。单一状态树可以更容易地跟踪随时间的变化，并调试或检查应用程序。

> 2、状态是只读的：改变状态的唯一方法是去触发一个动作。动作是描述变化的普通 JS 对象。就像 state 是数据的最小表示一样，该操作是对数据更改的最小表示。

> 3、使用纯函数进行更改：为了指定状态树如何通过操作进行转换，你需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。

> 4、组成结构：

> 1. Action – 这是一个用来描述发生了什么事情的对象。

> 2. Reducer – 这是一个确定状态将如何变化的地方。

> 3. Store – 整个程序的状态/对象树保存在Store中。

> 5、优点：

> 1. 结果的可预测性 – 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。

> 2. 可维护性 – 代码变得更容易维护，具有可预测的结果和严格的结构。

> 3. 服务器端渲染 – 你只需将服务器上创建的 store 传到客户端即可。这对初始渲染非常有用，并且可以优化应用性能，从而提供更好的用户体验。

> 4. 开发人员工具 – 从操作到状态更改，开发人员可以实时跟踪应用中发生的所有事情。

> 5. 社区和生态系统 – Redux 背后有一个巨大的社区，这使得它更加迷人。一个由才华横溢的人组成的大型社区为库的改进做出了贡献，并开发了各种应用。

> 6. 易于测试 – Redux 的代码主要是小巧、纯粹和独立的功能。这使代码可测试且独立。

## 算法知识总结

### 排序

> 冒泡排序

> > 冒泡排序的基本思想是，对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端， 最终达到完全有序。

> 选择排序

> > 选择排序的基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止。

> 快速排序

> > 快速排序的基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据 都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

> 插入排序

> > 直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的
有序序列中去，直到插完所有元素为止。

> 希尔排序

> > 希尔排序的基本思想是把数组按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的元素越来越多，当增量减至 1 时，整个数组恰被分成一组，算法便终止。

> 归并排序

> > 归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略。递归的将数组两两分开直到只包含一个元素，然后 将数组排序合并，最终合并为排序好的数组。

### js 如何实现数组扁平化

```
// 这一种方法通过递归来实现，当元素为数组时递归调用，兼容性好
function flattenArray(array) {
  if (!Array.isArray(array)) return;
  let result = [];
  result = array.reduce(function (pre, item) {
  // 判断元素是否为数组，如果为数组则递归调用，如果不是则加入结果数组中
    return pre.concat(Array.isArray(item) ? flattenArray(item) : item);
  }, []);
  return result;
}
// 这一种方法是利用了 toString 方法，它的一个缺点是改变了元素的类型，只适合于数组中元素都是整数的情况
function flattenArray(array) {
  return array.toString().split(",").map(function (item) {
    return +item;
  })
}
```

## 计算机网络知识总结

### HTTP

> HTTP是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用80端口。它使用TCP作为传输协议，保证了数据传输的可靠性。HTTP是一个无状态的协议，HTTP服务器不会保存关于客户的任何信息。HTTP有两种连接模式，一种是持续连接，一种是非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护 一个全新的连接。持续连接下，TCP连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP连接。HTTP1.1 以后默认采用的是持续的连接。

> 状态码：200-请求成功、202-服务器端已经收到请求消息，但是尚未进行处理 301-永久
移动、302-临时移动、304-所请求的资源未修改、 400-客户端请求的语法错误、404-请求的资源不存在 500-服务器内部错误。一般 1XX 代表服务器接收到请求、2XX 代表成功、3XX 代表重定向、4XX 代表客户端错误、5XX 代表服务器端错误。

### HTTP/2 协议

> 1、二进制协议

> 2、多路复用

> 3、数据流

> 4、头信息压缩

> 5、服务器推送

### HTTPS

> HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。使用 TLS/ SSL 协议，所有的信息都是加密的，第三方没有办法窃听。并且它提供了一种校验机制，信息一旦被篡改，通信的双方会立刻发现。它还配备了身份证书，防止身份被冒充的情况出现。

> 实现原理：

> 首先是对称加密的方法，对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就 是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法

> 非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户，都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加 密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。

> 因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存在的问题。

### TCP 三次握手的过程

> 第一次握手，客户端向服务器发送一个 SYN 连接请求报文段，报文段的首部中SYN标志位置为 1，序号字段是一个任选的随机数。它代表的是客户端数据的初始序号。

> 第二次握手，服务器端接收到客户端发送的 SYN 连接请求报文段后，服务器首先会为该连接分配 TCP 缓存和变量，然后向客户端发送 SYN ACK 报文段，报文段的首部中 SYN 和 ACK 标志位都被置为 1，代表这是一个对 SYN 连接请求的确认，同时序号字段是服务器端产生的一个任选的随机数，它代表的是服务器端数据的初始序号。确认号字段为客户端发送的序号加一。

> 第三次握手，客户端接收到服务器的肯定应答后，它也会为这次 TCP 连接分配缓存和变量，同时向服务器端发送一个对服务 器端的报文段的确认。第三次握手可以在报文段中携带数据。

### TCP 四次挥手的过程

> 第一次挥手，客户端认为没有数据要再发送给服务器端，它就向服务器发送一个FIN 报文段，申请断开客户端到服务器端的 连接。发送后客户端进入FIN_WAIT_1 状态。

> 第二次挥手，服务器端接收到客户端释放连接的请求后，向客户端发送一个确认报文段，表示已经接收到了客户端释放连接的 请求，以后不再接收客户端发送过来的数据。但是因为连接是全双工的，所以此时，服务器端还可以向客户端发送数据。服务 器端进入 CLOSE_WAIT 状态。客户端收到确认后，进入FIN_WAIT_2 状态。

> 第三次挥手，服务器端发送完所有数据后，向客户端发送 FIN 报文段，申请断开服务器端到客户端的连接。发送后进入 LAS T_ACK 状态。

> 第四次挥手，客户端接收到 FIN 请求后，向服务器端发送一个确认应答，并进入 TIME_WAIT 阶段。该阶段会持续一段时间， 这个时间为报文段在网络中的最大生存时间，如果该时间内服务端没有重发请求的话，客户端进入 CLOSED 的状态。如果收到 服务器的重发请求就重新发送确认报文段。服务器端收到客户端的确认报文段后就进入 CLOSED 状态，这样全双工的连接就被 释放了。

### 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么

> 1、首先会对URL进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的URL中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查URL中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。

> 2、浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。

> 3、下一步我们首先需要获取的是输入的URL中的域名的IP地址，首先会判断本地是否有该域名的IP地址的缓存，如果有则使用，如果没有则向本地DNS服务器发起请求。本地DNS服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的IP地址后，本地DNS服务器再将这个IP地址返回给请求的用户。用户向本地DNS服务器发起请求属于递归请求，本地DNS服务器向各级域名服务器发起请求属于迭代请求。

> 4、当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源MAC 地址，目的 MAC 地址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。

> 5、下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK 报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了

> 6、如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。

> 7、当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。

> 8、浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。

> 9、最后一步是 TCP 断开连接的四次挥手过程
