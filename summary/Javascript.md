# Javascript知识点总结

- js的基本数据类型

> undefined、Null、Boolean、Number、String以及ES6新增Symbol类型

- 栈和堆的定义

> 堆和栈的概念存在于数据结构中和操作系统内存中。在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全二叉树是堆的一种实现方式。在操作系统中，内存被分为栈区和堆区。栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。

- null和undefined的区别

> 两者都是基本数据类型，这两个基本数据类型分别都只有一个值，就是undefined和null。undefined代表的含义是未定义，null代表的含义是空对象。

- **JavaScript原型。原型链，有什么特点**

> 在js中我们是使用构造函数来创建一个对象的，每一个构造函数的内部都有一个prototype属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的prototype属性对应的值，在ES5中这个指针被称为对象的原型。一般来说我们是不应该能够获取到这个值的，但是现在浏览器中都实现__proto__属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为他不是规范中规定的。ES5中新增了一个Object.getPrototypeOf()方法，我们可以通过这个方法来获取对象的原型。当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，就会去它的原型对象去找，这就是原型链的概念。

- ==操作符的强制类型转换规则

> 字符串和数字之前的相等比较，将字符串转换为数字之后再进行比较

> 其他类型和布尔类型之间相等比较，先将布尔值转换为数字后，再应用其他规则进行比较

> null和undefined之间的相等比较，结果为真。其他值和他们进行比较都返回假值

> 对象和非对象之间的相等比较，对象先调用ToPrimitive抽象操作后，再进行比较

- **JavaScript创建对象的几种方式**

> 工厂模式，工厂模式的主要工作原理是用函数来封装对象的细节，从而通过调用函数来达到复用的目的。

> 构造函数模式，js中每一个函数都可以作为构造函数，只要一个函数通过new来调用的。

> 原型模式，因为每一个函数都有一个prototype属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。

> 组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式

> 动态原型模式，这是一种模式将原型方法复制的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。

> 寄生构造函数

- **JavaScript创建对象的几种方式**

> 原型链继承，缺点是引用类型的数据时，会被所有实例对象共享。

> 借用构造构造函数的方式

> 组合继承

> 原型式继承

> 寄生式继承

> 寄生式组合继承

- **This对象的理解**

> this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this的指向可以通过四种调用模式来判断。

> 函数调用模式，（不作为对象）this指向全局对象

> 方法调用模式，（作为对象）this指向这个对象

> 构造器调用模式，用new调用时，this指向这个新创建的对象

> apply 、 call 和 bind 调用模式，this指向都是不变的，除非使用new时

- eval 是做什么的

> 它的功能是把对应的字符串解析成 JS 代码并运行。应该避免使用 eval，不安全，非常耗性能（2 次，一次解析成 js 语句，一次执行）。

- 什么是闭包，为什么使用

> 是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。闭包有两个常用的用途。闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。

- **Ajax的创建流程**

> 1.创建XMLHttpRequest对象，也就是创建一个异步调用对象

> 2.创建一个新的HTTP请求，并指定该HTTP请求方法、URL及验证信息

> 3.设置响应HTTP请求状态变化函数

> 4.发送HTTP请求

> 5.获取异步调用返回的数据

> 6.使用js和DOM实现局部刷新

- **浏览器缓存机制**

> 浏览器的缓存机制指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。

> 强缓存策略：可以通过两种方式来设置，分别是http头信息中的Expires属性和Cache-Control属性。服务器通过在响应头中添加Expires属性，来指定资源过期时间。（这个是绝对时间）Cache-Control属性，通过设置max-age来指定资源能够被缓存的时间大小（这是相对时间）

> 协商缓存策略：可以通过两种方式来设置，分别是http头信息中的Etag属性和Last-Modified属性。Last-Modified属性来指出资源最后一次修改时间，下次请求时，会添加If-Modified-Since属性，来判断是否有修改，没有修改就返回304状态，使用本地缓存。另一种就是Etag属性，这个属性是资源生成的唯一标识符，进行对比后判断是否使用缓存。（Etag优先级高于Last-Modified）

- **如果解决跨域问题**

> 将document.domain设置为主域名，来实现相同子域名的跨域操作，主域名下的cookie就能被子域名所访问

> 使用location.hash的方法

> 使用window.name的方法

> 使用postMessage来解决的方法

> 使用jsonp来实现跨域请求

> 使用CORS的方式

> 使用websocket协议，这个协议没有同源限制

> 使用服务器来代理跨域的访问请求

- .call() 和 .apply() 的区别

> 作用都是一摸一样的，区别是在于传入参数的形式的不用

> apply接受两个参数，第一个参数指定了函数体内this对象的指向，第二个参数为一个带下表的集合，这个集合可以为数组，也可以为类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数。

> call传入的参数数量不固定，跟apply相同的是，第一个参数也是代表函数体内的this指向，从第二个参数开始往后，每个参数被依次传入函数。

- **如何编写高性能的 Javascript**

> 1.使用位运算代替一些简单的四则运算

> 2.避免使用过深的嵌套循环

> 3.不要使用未定义的变量

> 4.当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找

- **哪些操作会造成内存泄漏**

> 1.意外的全局变量

> 2.被遗忘的计时器或回调函数

> 3.脱离DOM的引用

> 4.闭包

- **js的节流和防抖**

> 函数防抖：在事件被触发n秒后再执行回调，如果这n秒内事件又被触发，则重新计时

> 函数节流：在规定一个单位时间，在这个时间内，只能有一次触发事件的回调函数执行

- **js的事件循环机制**

> 因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。

> 微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的MutationObserver。

> 宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。

## 前端安全相关

- xss攻击（跨站脚本攻击），如何防范xss攻击

> XSS 一般分为存储型、反射型和 DOM 型。存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为HTML 后返回给了用户，从而导致了恶意代码的执行。反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到HTML 后返回，从而导致了恶意代码的执行。DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。
XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。

- CSRF攻击（跨站请求伪造攻击），如何防范CSRF攻击

> CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。
第三种是链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。

> 预防方法：1、同源检测方法2、是使用 CSRF Token 来进行验证3、使用双重 Cookie 验证的办法4、是使用在设置 cookie 属性的时候设置 Samesite

- 点击劫持，如何防范点击劫持

> 点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。
我们可以在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 iframe 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特定的一些情况才能作为 iframe 来使用。
